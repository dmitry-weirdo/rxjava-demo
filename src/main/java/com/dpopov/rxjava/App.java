package com.dpopov.rxjava;

import io.reactivex.Observable;
import io.reactivex.schedulers.Schedulers;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {
    public String getGreeting() {
        return "Hello world.";
    }

    public static void main(final String[] args) {
//        System.out.println(new App().getGreeting());

        Observable.just("Hello observable world")
            .subscribe(System.out::println)
        ;

        Utils.printSeparator();

        // actually returns a Disposable, but we don't care for now
        Observable.range(1, 10)
            .subscribe(i -> System.out.printf("Number from range: %d \n", i) )
        ;

        Utils.printSeparator();

        // subscribe to fakeUserInput
        System.out.println("Fake user input:");

//        fakeUserInput()
        RxReader.linesFromInput()
            .map(Integer::parseInt)
            .observeOn( Schedulers.trampoline() ) // FIFO on participating threads
            .flatMapMaybe(x -> RxFibonacci.getFibonacciNumbers().elementAt(x) ) // elementAt(x) returns Maybe
//            .subscribe(System.out::println)
            .blockingSubscribe(System.out::println) // blockingSubscribe subscribe on the current thread
        ;

        Utils.printSeparator();
    }

    private static Observable<Integer> fakeUserInput() {
        final Random random = new Random();

        // difference of concatMap from flatMap is that flatMap may mix up the outputs from the Observables, while concatMap concats one output to the another, @see https://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/
        // @see http://reactivex.io/documentation/operators/flatmap.html, expand "RxJava 1â€¤x" node

        return Observable
//            .just(10, 17, 3, 8)
            .intervalRange(0, 20, 0, 500, TimeUnit.MILLISECONDS) // periodically with the same delay
//            .map(number -> random.nextInt(20)) // randoms between 0 and 20
            .concatMap( // transform observable to its result
                number -> Observable
                    .just( random.nextInt(20) )
                    .delay( random.nextInt(500), TimeUnit.MILLISECONDS ) // delay for a random within 500 milliseconds
            )
            .filter(i -> i > 3) // filter out values less than 3
        ;
    }
}